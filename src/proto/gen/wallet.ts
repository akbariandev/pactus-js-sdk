/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 3.21.12
 * source: wallet.proto
 * git: https://github.com/thesayyn/protoc-gen-ts */
import * as pb_1 from "google-protobuf";
import * as grpc_1 from "@grpc/grpc-js";
export namespace pactus {
    export enum AddressType {
        ADDRESS_TYPE_TREASURY = 0,
        ADDRESS_TYPE_VALIDATOR = 1,
        ADDRESS_TYPE_BLS_ACCOUNT = 2
    }
    export class AddressInfo extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            address?: string;
            public_key?: string;
            label?: string;
            path?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("address" in data && data.address != undefined) {
                    this.address = data.address;
                }
                if ("public_key" in data && data.public_key != undefined) {
                    this.public_key = data.public_key;
                }
                if ("label" in data && data.label != undefined) {
                    this.label = data.label;
                }
                if ("path" in data && data.path != undefined) {
                    this.path = data.path;
                }
            }
        }
        get address() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set address(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get public_key() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set public_key(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get label() {
            return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
        }
        set label(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        get path() {
            return pb_1.Message.getFieldWithDefault(this, 4, "") as string;
        }
        set path(value: string) {
            pb_1.Message.setField(this, 4, value);
        }
        static fromObject(data: {
            address?: string;
            public_key?: string;
            label?: string;
            path?: string;
        }): AddressInfo {
            const message = new AddressInfo({});
            if (data.address != null) {
                message.address = data.address;
            }
            if (data.public_key != null) {
                message.public_key = data.public_key;
            }
            if (data.label != null) {
                message.label = data.label;
            }
            if (data.path != null) {
                message.path = data.path;
            }
            return message;
        }
        toObject() {
            const data: {
                address?: string;
                public_key?: string;
                label?: string;
                path?: string;
            } = {};
            if (this.address != null) {
                data.address = this.address;
            }
            if (this.public_key != null) {
                data.public_key = this.public_key;
            }
            if (this.label != null) {
                data.label = this.label;
            }
            if (this.path != null) {
                data.path = this.path;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.address.length)
                writer.writeString(1, this.address);
            if (this.public_key.length)
                writer.writeString(2, this.public_key);
            if (this.label.length)
                writer.writeString(3, this.label);
            if (this.path.length)
                writer.writeString(4, this.path);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): AddressInfo {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new AddressInfo();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.address = reader.readString();
                        break;
                    case 2:
                        message.public_key = reader.readString();
                        break;
                    case 3:
                        message.label = reader.readString();
                        break;
                    case 4:
                        message.path = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): AddressInfo {
            return AddressInfo.deserialize(bytes);
        }
    }
    export class HistoryInfo extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            transaction_id?: string;
            time?: number;
            payload_type?: string;
            description?: string;
            amount?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("transaction_id" in data && data.transaction_id != undefined) {
                    this.transaction_id = data.transaction_id;
                }
                if ("time" in data && data.time != undefined) {
                    this.time = data.time;
                }
                if ("payload_type" in data && data.payload_type != undefined) {
                    this.payload_type = data.payload_type;
                }
                if ("description" in data && data.description != undefined) {
                    this.description = data.description;
                }
                if ("amount" in data && data.amount != undefined) {
                    this.amount = data.amount;
                }
            }
        }
        get transaction_id() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set transaction_id(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get time() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set time(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        get payload_type() {
            return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
        }
        set payload_type(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        get description() {
            return pb_1.Message.getFieldWithDefault(this, 4, "") as string;
        }
        set description(value: string) {
            pb_1.Message.setField(this, 4, value);
        }
        get amount() {
            return pb_1.Message.getFieldWithDefault(this, 5, 0) as number;
        }
        set amount(value: number) {
            pb_1.Message.setField(this, 5, value);
        }
        static fromObject(data: {
            transaction_id?: string;
            time?: number;
            payload_type?: string;
            description?: string;
            amount?: number;
        }): HistoryInfo {
            const message = new HistoryInfo({});
            if (data.transaction_id != null) {
                message.transaction_id = data.transaction_id;
            }
            if (data.time != null) {
                message.time = data.time;
            }
            if (data.payload_type != null) {
                message.payload_type = data.payload_type;
            }
            if (data.description != null) {
                message.description = data.description;
            }
            if (data.amount != null) {
                message.amount = data.amount;
            }
            return message;
        }
        toObject() {
            const data: {
                transaction_id?: string;
                time?: number;
                payload_type?: string;
                description?: string;
                amount?: number;
            } = {};
            if (this.transaction_id != null) {
                data.transaction_id = this.transaction_id;
            }
            if (this.time != null) {
                data.time = this.time;
            }
            if (this.payload_type != null) {
                data.payload_type = this.payload_type;
            }
            if (this.description != null) {
                data.description = this.description;
            }
            if (this.amount != null) {
                data.amount = this.amount;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.transaction_id.length)
                writer.writeString(1, this.transaction_id);
            if (this.time != 0)
                writer.writeUint32(2, this.time);
            if (this.payload_type.length)
                writer.writeString(3, this.payload_type);
            if (this.description.length)
                writer.writeString(4, this.description);
            if (this.amount != 0)
                writer.writeInt64(5, this.amount);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): HistoryInfo {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new HistoryInfo();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.transaction_id = reader.readString();
                        break;
                    case 2:
                        message.time = reader.readUint32();
                        break;
                    case 3:
                        message.payload_type = reader.readString();
                        break;
                    case 4:
                        message.description = reader.readString();
                        break;
                    case 5:
                        message.amount = reader.readInt64();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): HistoryInfo {
            return HistoryInfo.deserialize(bytes);
        }
    }
    export class GetAddressHistoryRequest extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            wallet_name?: string;
            address?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("wallet_name" in data && data.wallet_name != undefined) {
                    this.wallet_name = data.wallet_name;
                }
                if ("address" in data && data.address != undefined) {
                    this.address = data.address;
                }
            }
        }
        get wallet_name() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set wallet_name(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get address() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set address(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            wallet_name?: string;
            address?: string;
        }): GetAddressHistoryRequest {
            const message = new GetAddressHistoryRequest({});
            if (data.wallet_name != null) {
                message.wallet_name = data.wallet_name;
            }
            if (data.address != null) {
                message.address = data.address;
            }
            return message;
        }
        toObject() {
            const data: {
                wallet_name?: string;
                address?: string;
            } = {};
            if (this.wallet_name != null) {
                data.wallet_name = this.wallet_name;
            }
            if (this.address != null) {
                data.address = this.address;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.wallet_name.length)
                writer.writeString(1, this.wallet_name);
            if (this.address.length)
                writer.writeString(2, this.address);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): GetAddressHistoryRequest {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new GetAddressHistoryRequest();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.wallet_name = reader.readString();
                        break;
                    case 2:
                        message.address = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): GetAddressHistoryRequest {
            return GetAddressHistoryRequest.deserialize(bytes);
        }
    }
    export class GetAddressHistoryResponse extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            history_info?: HistoryInfo[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("history_info" in data && data.history_info != undefined) {
                    this.history_info = data.history_info;
                }
            }
        }
        get history_info() {
            return pb_1.Message.getRepeatedWrapperField(this, HistoryInfo, 1) as HistoryInfo[];
        }
        set history_info(value: HistoryInfo[]) {
            pb_1.Message.setRepeatedWrapperField(this, 1, value);
        }
        static fromObject(data: {
            history_info?: ReturnType<typeof HistoryInfo.prototype.toObject>[];
        }): GetAddressHistoryResponse {
            const message = new GetAddressHistoryResponse({});
            if (data.history_info != null) {
                message.history_info = data.history_info.map(item => HistoryInfo.fromObject(item));
            }
            return message;
        }
        toObject() {
            const data: {
                history_info?: ReturnType<typeof HistoryInfo.prototype.toObject>[];
            } = {};
            if (this.history_info != null) {
                data.history_info = this.history_info.map((item: HistoryInfo) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.history_info.length)
                writer.writeRepeatedMessage(1, this.history_info, (item: HistoryInfo) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): GetAddressHistoryResponse {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new GetAddressHistoryResponse();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.history_info, () => pb_1.Message.addToRepeatedWrapperField(message, 1, HistoryInfo.deserialize(reader), HistoryInfo));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): GetAddressHistoryResponse {
            return GetAddressHistoryResponse.deserialize(bytes);
        }
    }
    export class GetNewAddressRequest extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            wallet_name?: string;
            address_type?: AddressType;
            label?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("wallet_name" in data && data.wallet_name != undefined) {
                    this.wallet_name = data.wallet_name;
                }
                if ("address_type" in data && data.address_type != undefined) {
                    this.address_type = data.address_type;
                }
                if ("label" in data && data.label != undefined) {
                    this.label = data.label;
                }
            }
        }
        get wallet_name() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set wallet_name(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get address_type() {
            return pb_1.Message.getFieldWithDefault(this, 2, AddressType.ADDRESS_TYPE_TREASURY) as AddressType;
        }
        set address_type(value: AddressType) {
            pb_1.Message.setField(this, 2, value);
        }
        get label() {
            return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
        }
        set label(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        static fromObject(data: {
            wallet_name?: string;
            address_type?: AddressType;
            label?: string;
        }): GetNewAddressRequest {
            const message = new GetNewAddressRequest({});
            if (data.wallet_name != null) {
                message.wallet_name = data.wallet_name;
            }
            if (data.address_type != null) {
                message.address_type = data.address_type;
            }
            if (data.label != null) {
                message.label = data.label;
            }
            return message;
        }
        toObject() {
            const data: {
                wallet_name?: string;
                address_type?: AddressType;
                label?: string;
            } = {};
            if (this.wallet_name != null) {
                data.wallet_name = this.wallet_name;
            }
            if (this.address_type != null) {
                data.address_type = this.address_type;
            }
            if (this.label != null) {
                data.label = this.label;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.wallet_name.length)
                writer.writeString(1, this.wallet_name);
            if (this.address_type != AddressType.ADDRESS_TYPE_TREASURY)
                writer.writeEnum(2, this.address_type);
            if (this.label.length)
                writer.writeString(3, this.label);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): GetNewAddressRequest {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new GetNewAddressRequest();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.wallet_name = reader.readString();
                        break;
                    case 2:
                        message.address_type = reader.readEnum();
                        break;
                    case 3:
                        message.label = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): GetNewAddressRequest {
            return GetNewAddressRequest.deserialize(bytes);
        }
    }
    export class GetNewAddressResponse extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            wallet_name?: string;
            address_info?: AddressInfo;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("wallet_name" in data && data.wallet_name != undefined) {
                    this.wallet_name = data.wallet_name;
                }
                if ("address_info" in data && data.address_info != undefined) {
                    this.address_info = data.address_info;
                }
            }
        }
        get wallet_name() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set wallet_name(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get address_info() {
            return pb_1.Message.getWrapperField(this, AddressInfo, 2) as AddressInfo;
        }
        set address_info(value: AddressInfo) {
            pb_1.Message.setWrapperField(this, 2, value);
        }
        get has_address_info() {
            return pb_1.Message.getField(this, 2) != null;
        }
        static fromObject(data: {
            wallet_name?: string;
            address_info?: ReturnType<typeof AddressInfo.prototype.toObject>;
        }): GetNewAddressResponse {
            const message = new GetNewAddressResponse({});
            if (data.wallet_name != null) {
                message.wallet_name = data.wallet_name;
            }
            if (data.address_info != null) {
                message.address_info = AddressInfo.fromObject(data.address_info);
            }
            return message;
        }
        toObject() {
            const data: {
                wallet_name?: string;
                address_info?: ReturnType<typeof AddressInfo.prototype.toObject>;
            } = {};
            if (this.wallet_name != null) {
                data.wallet_name = this.wallet_name;
            }
            if (this.address_info != null) {
                data.address_info = this.address_info.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.wallet_name.length)
                writer.writeString(1, this.wallet_name);
            if (this.has_address_info)
                writer.writeMessage(2, this.address_info, () => this.address_info.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): GetNewAddressResponse {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new GetNewAddressResponse();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.wallet_name = reader.readString();
                        break;
                    case 2:
                        reader.readMessage(message.address_info, () => message.address_info = AddressInfo.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): GetNewAddressResponse {
            return GetNewAddressResponse.deserialize(bytes);
        }
    }
    export class RestoreWalletRequest extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            wallet_name?: string;
            mnemonic?: string;
            password?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("wallet_name" in data && data.wallet_name != undefined) {
                    this.wallet_name = data.wallet_name;
                }
                if ("mnemonic" in data && data.mnemonic != undefined) {
                    this.mnemonic = data.mnemonic;
                }
                if ("password" in data && data.password != undefined) {
                    this.password = data.password;
                }
            }
        }
        get wallet_name() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set wallet_name(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get mnemonic() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set mnemonic(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get password() {
            return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
        }
        set password(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        static fromObject(data: {
            wallet_name?: string;
            mnemonic?: string;
            password?: string;
        }): RestoreWalletRequest {
            const message = new RestoreWalletRequest({});
            if (data.wallet_name != null) {
                message.wallet_name = data.wallet_name;
            }
            if (data.mnemonic != null) {
                message.mnemonic = data.mnemonic;
            }
            if (data.password != null) {
                message.password = data.password;
            }
            return message;
        }
        toObject() {
            const data: {
                wallet_name?: string;
                mnemonic?: string;
                password?: string;
            } = {};
            if (this.wallet_name != null) {
                data.wallet_name = this.wallet_name;
            }
            if (this.mnemonic != null) {
                data.mnemonic = this.mnemonic;
            }
            if (this.password != null) {
                data.password = this.password;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.wallet_name.length)
                writer.writeString(1, this.wallet_name);
            if (this.mnemonic.length)
                writer.writeString(2, this.mnemonic);
            if (this.password.length)
                writer.writeString(3, this.password);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): RestoreWalletRequest {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new RestoreWalletRequest();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.wallet_name = reader.readString();
                        break;
                    case 2:
                        message.mnemonic = reader.readString();
                        break;
                    case 3:
                        message.password = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): RestoreWalletRequest {
            return RestoreWalletRequest.deserialize(bytes);
        }
    }
    export class RestoreWalletResponse extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            wallet_name?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("wallet_name" in data && data.wallet_name != undefined) {
                    this.wallet_name = data.wallet_name;
                }
            }
        }
        get wallet_name() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set wallet_name(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data: {
            wallet_name?: string;
        }): RestoreWalletResponse {
            const message = new RestoreWalletResponse({});
            if (data.wallet_name != null) {
                message.wallet_name = data.wallet_name;
            }
            return message;
        }
        toObject() {
            const data: {
                wallet_name?: string;
            } = {};
            if (this.wallet_name != null) {
                data.wallet_name = this.wallet_name;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.wallet_name.length)
                writer.writeString(1, this.wallet_name);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): RestoreWalletResponse {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new RestoreWalletResponse();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.wallet_name = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): RestoreWalletResponse {
            return RestoreWalletResponse.deserialize(bytes);
        }
    }
    export class CreateWalletRequest extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            wallet_name?: string;
            password?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("wallet_name" in data && data.wallet_name != undefined) {
                    this.wallet_name = data.wallet_name;
                }
                if ("password" in data && data.password != undefined) {
                    this.password = data.password;
                }
            }
        }
        get wallet_name() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set wallet_name(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get password() {
            return pb_1.Message.getFieldWithDefault(this, 4, "") as string;
        }
        set password(value: string) {
            pb_1.Message.setField(this, 4, value);
        }
        static fromObject(data: {
            wallet_name?: string;
            password?: string;
        }): CreateWalletRequest {
            const message = new CreateWalletRequest({});
            if (data.wallet_name != null) {
                message.wallet_name = data.wallet_name;
            }
            if (data.password != null) {
                message.password = data.password;
            }
            return message;
        }
        toObject() {
            const data: {
                wallet_name?: string;
                password?: string;
            } = {};
            if (this.wallet_name != null) {
                data.wallet_name = this.wallet_name;
            }
            if (this.password != null) {
                data.password = this.password;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.wallet_name.length)
                writer.writeString(1, this.wallet_name);
            if (this.password.length)
                writer.writeString(4, this.password);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): CreateWalletRequest {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new CreateWalletRequest();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.wallet_name = reader.readString();
                        break;
                    case 4:
                        message.password = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): CreateWalletRequest {
            return CreateWalletRequest.deserialize(bytes);
        }
    }
    export class CreateWalletResponse extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            mnemonic?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("mnemonic" in data && data.mnemonic != undefined) {
                    this.mnemonic = data.mnemonic;
                }
            }
        }
        get mnemonic() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set mnemonic(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            mnemonic?: string;
        }): CreateWalletResponse {
            const message = new CreateWalletResponse({});
            if (data.mnemonic != null) {
                message.mnemonic = data.mnemonic;
            }
            return message;
        }
        toObject() {
            const data: {
                mnemonic?: string;
            } = {};
            if (this.mnemonic != null) {
                data.mnemonic = this.mnemonic;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.mnemonic.length)
                writer.writeString(2, this.mnemonic);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): CreateWalletResponse {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new CreateWalletResponse();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 2:
                        message.mnemonic = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): CreateWalletResponse {
            return CreateWalletResponse.deserialize(bytes);
        }
    }
    export class LoadWalletRequest extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            wallet_name?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("wallet_name" in data && data.wallet_name != undefined) {
                    this.wallet_name = data.wallet_name;
                }
            }
        }
        get wallet_name() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set wallet_name(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data: {
            wallet_name?: string;
        }): LoadWalletRequest {
            const message = new LoadWalletRequest({});
            if (data.wallet_name != null) {
                message.wallet_name = data.wallet_name;
            }
            return message;
        }
        toObject() {
            const data: {
                wallet_name?: string;
            } = {};
            if (this.wallet_name != null) {
                data.wallet_name = this.wallet_name;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.wallet_name.length)
                writer.writeString(1, this.wallet_name);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): LoadWalletRequest {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new LoadWalletRequest();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.wallet_name = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): LoadWalletRequest {
            return LoadWalletRequest.deserialize(bytes);
        }
    }
    export class LoadWalletResponse extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            wallet_name?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("wallet_name" in data && data.wallet_name != undefined) {
                    this.wallet_name = data.wallet_name;
                }
            }
        }
        get wallet_name() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set wallet_name(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data: {
            wallet_name?: string;
        }): LoadWalletResponse {
            const message = new LoadWalletResponse({});
            if (data.wallet_name != null) {
                message.wallet_name = data.wallet_name;
            }
            return message;
        }
        toObject() {
            const data: {
                wallet_name?: string;
            } = {};
            if (this.wallet_name != null) {
                data.wallet_name = this.wallet_name;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.wallet_name.length)
                writer.writeString(1, this.wallet_name);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): LoadWalletResponse {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new LoadWalletResponse();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.wallet_name = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): LoadWalletResponse {
            return LoadWalletResponse.deserialize(bytes);
        }
    }
    export class UnloadWalletRequest extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            wallet_name?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("wallet_name" in data && data.wallet_name != undefined) {
                    this.wallet_name = data.wallet_name;
                }
            }
        }
        get wallet_name() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set wallet_name(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data: {
            wallet_name?: string;
        }): UnloadWalletRequest {
            const message = new UnloadWalletRequest({});
            if (data.wallet_name != null) {
                message.wallet_name = data.wallet_name;
            }
            return message;
        }
        toObject() {
            const data: {
                wallet_name?: string;
            } = {};
            if (this.wallet_name != null) {
                data.wallet_name = this.wallet_name;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.wallet_name.length)
                writer.writeString(1, this.wallet_name);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): UnloadWalletRequest {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new UnloadWalletRequest();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.wallet_name = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): UnloadWalletRequest {
            return UnloadWalletRequest.deserialize(bytes);
        }
    }
    export class UnloadWalletResponse extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            wallet_name?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("wallet_name" in data && data.wallet_name != undefined) {
                    this.wallet_name = data.wallet_name;
                }
            }
        }
        get wallet_name() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set wallet_name(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data: {
            wallet_name?: string;
        }): UnloadWalletResponse {
            const message = new UnloadWalletResponse({});
            if (data.wallet_name != null) {
                message.wallet_name = data.wallet_name;
            }
            return message;
        }
        toObject() {
            const data: {
                wallet_name?: string;
            } = {};
            if (this.wallet_name != null) {
                data.wallet_name = this.wallet_name;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.wallet_name.length)
                writer.writeString(1, this.wallet_name);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): UnloadWalletResponse {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new UnloadWalletResponse();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.wallet_name = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): UnloadWalletResponse {
            return UnloadWalletResponse.deserialize(bytes);
        }
    }
    export class GetValidatorAddressRequest extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            public_key?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("public_key" in data && data.public_key != undefined) {
                    this.public_key = data.public_key;
                }
            }
        }
        get public_key() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set public_key(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data: {
            public_key?: string;
        }): GetValidatorAddressRequest {
            const message = new GetValidatorAddressRequest({});
            if (data.public_key != null) {
                message.public_key = data.public_key;
            }
            return message;
        }
        toObject() {
            const data: {
                public_key?: string;
            } = {};
            if (this.public_key != null) {
                data.public_key = this.public_key;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.public_key.length)
                writer.writeString(1, this.public_key);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): GetValidatorAddressRequest {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new GetValidatorAddressRequest();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.public_key = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): GetValidatorAddressRequest {
            return GetValidatorAddressRequest.deserialize(bytes);
        }
    }
    export class GetValidatorAddressResponse extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            address?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("address" in data && data.address != undefined) {
                    this.address = data.address;
                }
            }
        }
        get address() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set address(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data: {
            address?: string;
        }): GetValidatorAddressResponse {
            const message = new GetValidatorAddressResponse({});
            if (data.address != null) {
                message.address = data.address;
            }
            return message;
        }
        toObject() {
            const data: {
                address?: string;
            } = {};
            if (this.address != null) {
                data.address = this.address;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.address.length)
                writer.writeString(1, this.address);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): GetValidatorAddressResponse {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new GetValidatorAddressResponse();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.address = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): GetValidatorAddressResponse {
            return GetValidatorAddressResponse.deserialize(bytes);
        }
    }
    export class SignRawTransactionRequest extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            wallet_name?: string;
            raw_transaction?: string;
            password?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("wallet_name" in data && data.wallet_name != undefined) {
                    this.wallet_name = data.wallet_name;
                }
                if ("raw_transaction" in data && data.raw_transaction != undefined) {
                    this.raw_transaction = data.raw_transaction;
                }
                if ("password" in data && data.password != undefined) {
                    this.password = data.password;
                }
            }
        }
        get wallet_name() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set wallet_name(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get raw_transaction() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set raw_transaction(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get password() {
            return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
        }
        set password(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        static fromObject(data: {
            wallet_name?: string;
            raw_transaction?: string;
            password?: string;
        }): SignRawTransactionRequest {
            const message = new SignRawTransactionRequest({});
            if (data.wallet_name != null) {
                message.wallet_name = data.wallet_name;
            }
            if (data.raw_transaction != null) {
                message.raw_transaction = data.raw_transaction;
            }
            if (data.password != null) {
                message.password = data.password;
            }
            return message;
        }
        toObject() {
            const data: {
                wallet_name?: string;
                raw_transaction?: string;
                password?: string;
            } = {};
            if (this.wallet_name != null) {
                data.wallet_name = this.wallet_name;
            }
            if (this.raw_transaction != null) {
                data.raw_transaction = this.raw_transaction;
            }
            if (this.password != null) {
                data.password = this.password;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.wallet_name.length)
                writer.writeString(1, this.wallet_name);
            if (this.raw_transaction.length)
                writer.writeString(2, this.raw_transaction);
            if (this.password.length)
                writer.writeString(3, this.password);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): SignRawTransactionRequest {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new SignRawTransactionRequest();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.wallet_name = reader.readString();
                        break;
                    case 2:
                        message.raw_transaction = reader.readString();
                        break;
                    case 3:
                        message.password = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): SignRawTransactionRequest {
            return SignRawTransactionRequest.deserialize(bytes);
        }
    }
    export class SignRawTransactionResponse extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            transaction_id?: string;
            signed_raw_transaction?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("transaction_id" in data && data.transaction_id != undefined) {
                    this.transaction_id = data.transaction_id;
                }
                if ("signed_raw_transaction" in data && data.signed_raw_transaction != undefined) {
                    this.signed_raw_transaction = data.signed_raw_transaction;
                }
            }
        }
        get transaction_id() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set transaction_id(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get signed_raw_transaction() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set signed_raw_transaction(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            transaction_id?: string;
            signed_raw_transaction?: string;
        }): SignRawTransactionResponse {
            const message = new SignRawTransactionResponse({});
            if (data.transaction_id != null) {
                message.transaction_id = data.transaction_id;
            }
            if (data.signed_raw_transaction != null) {
                message.signed_raw_transaction = data.signed_raw_transaction;
            }
            return message;
        }
        toObject() {
            const data: {
                transaction_id?: string;
                signed_raw_transaction?: string;
            } = {};
            if (this.transaction_id != null) {
                data.transaction_id = this.transaction_id;
            }
            if (this.signed_raw_transaction != null) {
                data.signed_raw_transaction = this.signed_raw_transaction;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.transaction_id.length)
                writer.writeString(1, this.transaction_id);
            if (this.signed_raw_transaction.length)
                writer.writeString(2, this.signed_raw_transaction);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): SignRawTransactionResponse {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new SignRawTransactionResponse();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.transaction_id = reader.readString();
                        break;
                    case 2:
                        message.signed_raw_transaction = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): SignRawTransactionResponse {
            return SignRawTransactionResponse.deserialize(bytes);
        }
    }
    export class GetTotalBalanceRequest extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            wallet_name?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("wallet_name" in data && data.wallet_name != undefined) {
                    this.wallet_name = data.wallet_name;
                }
            }
        }
        get wallet_name() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set wallet_name(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data: {
            wallet_name?: string;
        }): GetTotalBalanceRequest {
            const message = new GetTotalBalanceRequest({});
            if (data.wallet_name != null) {
                message.wallet_name = data.wallet_name;
            }
            return message;
        }
        toObject() {
            const data: {
                wallet_name?: string;
            } = {};
            if (this.wallet_name != null) {
                data.wallet_name = this.wallet_name;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.wallet_name.length)
                writer.writeString(1, this.wallet_name);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): GetTotalBalanceRequest {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new GetTotalBalanceRequest();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.wallet_name = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): GetTotalBalanceRequest {
            return GetTotalBalanceRequest.deserialize(bytes);
        }
    }
    export class GetTotalBalanceResponse extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            wallet_name?: string;
            total_balance?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("wallet_name" in data && data.wallet_name != undefined) {
                    this.wallet_name = data.wallet_name;
                }
                if ("total_balance" in data && data.total_balance != undefined) {
                    this.total_balance = data.total_balance;
                }
            }
        }
        get wallet_name() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set wallet_name(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get total_balance() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set total_balance(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            wallet_name?: string;
            total_balance?: number;
        }): GetTotalBalanceResponse {
            const message = new GetTotalBalanceResponse({});
            if (data.wallet_name != null) {
                message.wallet_name = data.wallet_name;
            }
            if (data.total_balance != null) {
                message.total_balance = data.total_balance;
            }
            return message;
        }
        toObject() {
            const data: {
                wallet_name?: string;
                total_balance?: number;
            } = {};
            if (this.wallet_name != null) {
                data.wallet_name = this.wallet_name;
            }
            if (this.total_balance != null) {
                data.total_balance = this.total_balance;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.wallet_name.length)
                writer.writeString(1, this.wallet_name);
            if (this.total_balance != 0)
                writer.writeInt64(2, this.total_balance);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): GetTotalBalanceResponse {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new GetTotalBalanceResponse();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.wallet_name = reader.readString();
                        break;
                    case 2:
                        message.total_balance = reader.readInt64();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): GetTotalBalanceResponse {
            return GetTotalBalanceResponse.deserialize(bytes);
        }
    }
    export class SignMessageRequest extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            wallet_name?: string;
            password?: string;
            address?: string;
            message?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("wallet_name" in data && data.wallet_name != undefined) {
                    this.wallet_name = data.wallet_name;
                }
                if ("password" in data && data.password != undefined) {
                    this.password = data.password;
                }
                if ("address" in data && data.address != undefined) {
                    this.address = data.address;
                }
                if ("message" in data && data.message != undefined) {
                    this.message = data.message;
                }
            }
        }
        get wallet_name() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set wallet_name(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get password() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set password(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get address() {
            return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
        }
        set address(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        get message() {
            return pb_1.Message.getFieldWithDefault(this, 4, "") as string;
        }
        set message(value: string) {
            pb_1.Message.setField(this, 4, value);
        }
        static fromObject(data: {
            wallet_name?: string;
            password?: string;
            address?: string;
            message?: string;
        }): SignMessageRequest {
            const message = new SignMessageRequest({});
            if (data.wallet_name != null) {
                message.wallet_name = data.wallet_name;
            }
            if (data.password != null) {
                message.password = data.password;
            }
            if (data.address != null) {
                message.address = data.address;
            }
            if (data.message != null) {
                message.message = data.message;
            }
            return message;
        }
        toObject() {
            const data: {
                wallet_name?: string;
                password?: string;
                address?: string;
                message?: string;
            } = {};
            if (this.wallet_name != null) {
                data.wallet_name = this.wallet_name;
            }
            if (this.password != null) {
                data.password = this.password;
            }
            if (this.address != null) {
                data.address = this.address;
            }
            if (this.message != null) {
                data.message = this.message;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.wallet_name.length)
                writer.writeString(1, this.wallet_name);
            if (this.password.length)
                writer.writeString(2, this.password);
            if (this.address.length)
                writer.writeString(3, this.address);
            if (this.message.length)
                writer.writeString(4, this.message);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): SignMessageRequest {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new SignMessageRequest();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.wallet_name = reader.readString();
                        break;
                    case 2:
                        message.password = reader.readString();
                        break;
                    case 3:
                        message.address = reader.readString();
                        break;
                    case 4:
                        message.message = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): SignMessageRequest {
            return SignMessageRequest.deserialize(bytes);
        }
    }
    export class SignMessageResponse extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            signature?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("signature" in data && data.signature != undefined) {
                    this.signature = data.signature;
                }
            }
        }
        get signature() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set signature(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data: {
            signature?: string;
        }): SignMessageResponse {
            const message = new SignMessageResponse({});
            if (data.signature != null) {
                message.signature = data.signature;
            }
            return message;
        }
        toObject() {
            const data: {
                signature?: string;
            } = {};
            if (this.signature != null) {
                data.signature = this.signature;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.signature.length)
                writer.writeString(1, this.signature);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): SignMessageResponse {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new SignMessageResponse();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.signature = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): SignMessageResponse {
            return SignMessageResponse.deserialize(bytes);
        }
    }
    interface GrpcUnaryServiceInterface<P, R> {
        (message: P, metadata: grpc_1.Metadata, options: grpc_1.CallOptions, callback: grpc_1.requestCallback<R>): grpc_1.ClientUnaryCall;
        (message: P, metadata: grpc_1.Metadata, callback: grpc_1.requestCallback<R>): grpc_1.ClientUnaryCall;
        (message: P, options: grpc_1.CallOptions, callback: grpc_1.requestCallback<R>): grpc_1.ClientUnaryCall;
        (message: P, callback: grpc_1.requestCallback<R>): grpc_1.ClientUnaryCall;
    }
    interface GrpcStreamServiceInterface<P, R> {
        (message: P, metadata: grpc_1.Metadata, options?: grpc_1.CallOptions): grpc_1.ClientReadableStream<R>;
        (message: P, options?: grpc_1.CallOptions): grpc_1.ClientReadableStream<R>;
    }
    interface GrpWritableServiceInterface<P, R> {
        (metadata: grpc_1.Metadata, options: grpc_1.CallOptions, callback: grpc_1.requestCallback<R>): grpc_1.ClientWritableStream<P>;
        (metadata: grpc_1.Metadata, callback: grpc_1.requestCallback<R>): grpc_1.ClientWritableStream<P>;
        (options: grpc_1.CallOptions, callback: grpc_1.requestCallback<R>): grpc_1.ClientWritableStream<P>;
        (callback: grpc_1.requestCallback<R>): grpc_1.ClientWritableStream<P>;
    }
    interface GrpcChunkServiceInterface<P, R> {
        (metadata: grpc_1.Metadata, options?: grpc_1.CallOptions): grpc_1.ClientDuplexStream<P, R>;
        (options?: grpc_1.CallOptions): grpc_1.ClientDuplexStream<P, R>;
    }
    interface GrpcPromiseServiceInterface<P, R> {
        (message: P, metadata: grpc_1.Metadata, options?: grpc_1.CallOptions): Promise<R>;
        (message: P, options?: grpc_1.CallOptions): Promise<R>;
    }
    export abstract class UnimplementedWalletService {
        static definition = {
            CreateWallet: {
                path: "/pactus.Wallet/CreateWallet",
                requestStream: false,
                responseStream: false,
                requestSerialize: (message: CreateWalletRequest) => Buffer.from(message.serialize()),
                requestDeserialize: (bytes: Buffer) => CreateWalletRequest.deserialize(new Uint8Array(bytes)),
                responseSerialize: (message: CreateWalletResponse) => Buffer.from(message.serialize()),
                responseDeserialize: (bytes: Buffer) => CreateWalletResponse.deserialize(new Uint8Array(bytes))
            },
            RestoreWallet: {
                path: "/pactus.Wallet/RestoreWallet",
                requestStream: false,
                responseStream: false,
                requestSerialize: (message: RestoreWalletRequest) => Buffer.from(message.serialize()),
                requestDeserialize: (bytes: Buffer) => RestoreWalletRequest.deserialize(new Uint8Array(bytes)),
                responseSerialize: (message: RestoreWalletResponse) => Buffer.from(message.serialize()),
                responseDeserialize: (bytes: Buffer) => RestoreWalletResponse.deserialize(new Uint8Array(bytes))
            },
            LoadWallet: {
                path: "/pactus.Wallet/LoadWallet",
                requestStream: false,
                responseStream: false,
                requestSerialize: (message: LoadWalletRequest) => Buffer.from(message.serialize()),
                requestDeserialize: (bytes: Buffer) => LoadWalletRequest.deserialize(new Uint8Array(bytes)),
                responseSerialize: (message: LoadWalletResponse) => Buffer.from(message.serialize()),
                responseDeserialize: (bytes: Buffer) => LoadWalletResponse.deserialize(new Uint8Array(bytes))
            },
            UnloadWallet: {
                path: "/pactus.Wallet/UnloadWallet",
                requestStream: false,
                responseStream: false,
                requestSerialize: (message: UnloadWalletRequest) => Buffer.from(message.serialize()),
                requestDeserialize: (bytes: Buffer) => UnloadWalletRequest.deserialize(new Uint8Array(bytes)),
                responseSerialize: (message: UnloadWalletResponse) => Buffer.from(message.serialize()),
                responseDeserialize: (bytes: Buffer) => UnloadWalletResponse.deserialize(new Uint8Array(bytes))
            },
            GetTotalBalance: {
                path: "/pactus.Wallet/GetTotalBalance",
                requestStream: false,
                responseStream: false,
                requestSerialize: (message: GetTotalBalanceRequest) => Buffer.from(message.serialize()),
                requestDeserialize: (bytes: Buffer) => GetTotalBalanceRequest.deserialize(new Uint8Array(bytes)),
                responseSerialize: (message: GetTotalBalanceResponse) => Buffer.from(message.serialize()),
                responseDeserialize: (bytes: Buffer) => GetTotalBalanceResponse.deserialize(new Uint8Array(bytes))
            },
            SignRawTransaction: {
                path: "/pactus.Wallet/SignRawTransaction",
                requestStream: false,
                responseStream: false,
                requestSerialize: (message: SignRawTransactionRequest) => Buffer.from(message.serialize()),
                requestDeserialize: (bytes: Buffer) => SignRawTransactionRequest.deserialize(new Uint8Array(bytes)),
                responseSerialize: (message: SignRawTransactionResponse) => Buffer.from(message.serialize()),
                responseDeserialize: (bytes: Buffer) => SignRawTransactionResponse.deserialize(new Uint8Array(bytes))
            },
            GetValidatorAddress: {
                path: "/pactus.Wallet/GetValidatorAddress",
                requestStream: false,
                responseStream: false,
                requestSerialize: (message: GetValidatorAddressRequest) => Buffer.from(message.serialize()),
                requestDeserialize: (bytes: Buffer) => GetValidatorAddressRequest.deserialize(new Uint8Array(bytes)),
                responseSerialize: (message: GetValidatorAddressResponse) => Buffer.from(message.serialize()),
                responseDeserialize: (bytes: Buffer) => GetValidatorAddressResponse.deserialize(new Uint8Array(bytes))
            },
            GetNewAddress: {
                path: "/pactus.Wallet/GetNewAddress",
                requestStream: false,
                responseStream: false,
                requestSerialize: (message: GetNewAddressRequest) => Buffer.from(message.serialize()),
                requestDeserialize: (bytes: Buffer) => GetNewAddressRequest.deserialize(new Uint8Array(bytes)),
                responseSerialize: (message: GetNewAddressResponse) => Buffer.from(message.serialize()),
                responseDeserialize: (bytes: Buffer) => GetNewAddressResponse.deserialize(new Uint8Array(bytes))
            },
            GetAddressHistory: {
                path: "/pactus.Wallet/GetAddressHistory",
                requestStream: false,
                responseStream: false,
                requestSerialize: (message: GetAddressHistoryRequest) => Buffer.from(message.serialize()),
                requestDeserialize: (bytes: Buffer) => GetAddressHistoryRequest.deserialize(new Uint8Array(bytes)),
                responseSerialize: (message: GetAddressHistoryResponse) => Buffer.from(message.serialize()),
                responseDeserialize: (bytes: Buffer) => GetAddressHistoryResponse.deserialize(new Uint8Array(bytes))
            },
            SignMessage: {
                path: "/pactus.Wallet/SignMessage",
                requestStream: false,
                responseStream: false,
                requestSerialize: (message: SignMessageRequest) => Buffer.from(message.serialize()),
                requestDeserialize: (bytes: Buffer) => SignMessageRequest.deserialize(new Uint8Array(bytes)),
                responseSerialize: (message: SignMessageResponse) => Buffer.from(message.serialize()),
                responseDeserialize: (bytes: Buffer) => SignMessageResponse.deserialize(new Uint8Array(bytes))
            }
        };
        [method: string]: grpc_1.UntypedHandleCall;
        abstract CreateWallet(call: grpc_1.ServerUnaryCall<CreateWalletRequest, CreateWalletResponse>, callback: grpc_1.sendUnaryData<CreateWalletResponse>): void;
        abstract RestoreWallet(call: grpc_1.ServerUnaryCall<RestoreWalletRequest, RestoreWalletResponse>, callback: grpc_1.sendUnaryData<RestoreWalletResponse>): void;
        abstract LoadWallet(call: grpc_1.ServerUnaryCall<LoadWalletRequest, LoadWalletResponse>, callback: grpc_1.sendUnaryData<LoadWalletResponse>): void;
        abstract UnloadWallet(call: grpc_1.ServerUnaryCall<UnloadWalletRequest, UnloadWalletResponse>, callback: grpc_1.sendUnaryData<UnloadWalletResponse>): void;
        abstract GetTotalBalance(call: grpc_1.ServerUnaryCall<GetTotalBalanceRequest, GetTotalBalanceResponse>, callback: grpc_1.sendUnaryData<GetTotalBalanceResponse>): void;
        abstract SignRawTransaction(call: grpc_1.ServerUnaryCall<SignRawTransactionRequest, SignRawTransactionResponse>, callback: grpc_1.sendUnaryData<SignRawTransactionResponse>): void;
        abstract GetValidatorAddress(call: grpc_1.ServerUnaryCall<GetValidatorAddressRequest, GetValidatorAddressResponse>, callback: grpc_1.sendUnaryData<GetValidatorAddressResponse>): void;
        abstract GetNewAddress(call: grpc_1.ServerUnaryCall<GetNewAddressRequest, GetNewAddressResponse>, callback: grpc_1.sendUnaryData<GetNewAddressResponse>): void;
        abstract GetAddressHistory(call: grpc_1.ServerUnaryCall<GetAddressHistoryRequest, GetAddressHistoryResponse>, callback: grpc_1.sendUnaryData<GetAddressHistoryResponse>): void;
        abstract SignMessage(call: grpc_1.ServerUnaryCall<SignMessageRequest, SignMessageResponse>, callback: grpc_1.sendUnaryData<SignMessageResponse>): void;
    }
    export class WalletClient extends grpc_1.makeGenericClientConstructor(UnimplementedWalletService.definition, "Wallet", {}) {
        constructor(address: string, credentials: grpc_1.ChannelCredentials, options?: Partial<grpc_1.ChannelOptions>) {
            super(address, credentials, options);
        }
        CreateWallet: GrpcUnaryServiceInterface<CreateWalletRequest, CreateWalletResponse> = (message: CreateWalletRequest, metadata: grpc_1.Metadata | grpc_1.CallOptions | grpc_1.requestCallback<CreateWalletResponse>, options?: grpc_1.CallOptions | grpc_1.requestCallback<CreateWalletResponse>, callback?: grpc_1.requestCallback<CreateWalletResponse>): grpc_1.ClientUnaryCall => {
            return super.CreateWallet(message, metadata, options, callback);
        };
        RestoreWallet: GrpcUnaryServiceInterface<RestoreWalletRequest, RestoreWalletResponse> = (message: RestoreWalletRequest, metadata: grpc_1.Metadata | grpc_1.CallOptions | grpc_1.requestCallback<RestoreWalletResponse>, options?: grpc_1.CallOptions | grpc_1.requestCallback<RestoreWalletResponse>, callback?: grpc_1.requestCallback<RestoreWalletResponse>): grpc_1.ClientUnaryCall => {
            return super.RestoreWallet(message, metadata, options, callback);
        };
        LoadWallet: GrpcUnaryServiceInterface<LoadWalletRequest, LoadWalletResponse> = (message: LoadWalletRequest, metadata: grpc_1.Metadata | grpc_1.CallOptions | grpc_1.requestCallback<LoadWalletResponse>, options?: grpc_1.CallOptions | grpc_1.requestCallback<LoadWalletResponse>, callback?: grpc_1.requestCallback<LoadWalletResponse>): grpc_1.ClientUnaryCall => {
            return super.LoadWallet(message, metadata, options, callback);
        };
        UnloadWallet: GrpcUnaryServiceInterface<UnloadWalletRequest, UnloadWalletResponse> = (message: UnloadWalletRequest, metadata: grpc_1.Metadata | grpc_1.CallOptions | grpc_1.requestCallback<UnloadWalletResponse>, options?: grpc_1.CallOptions | grpc_1.requestCallback<UnloadWalletResponse>, callback?: grpc_1.requestCallback<UnloadWalletResponse>): grpc_1.ClientUnaryCall => {
            return super.UnloadWallet(message, metadata, options, callback);
        };
        GetTotalBalance: GrpcUnaryServiceInterface<GetTotalBalanceRequest, GetTotalBalanceResponse> = (message: GetTotalBalanceRequest, metadata: grpc_1.Metadata | grpc_1.CallOptions | grpc_1.requestCallback<GetTotalBalanceResponse>, options?: grpc_1.CallOptions | grpc_1.requestCallback<GetTotalBalanceResponse>, callback?: grpc_1.requestCallback<GetTotalBalanceResponse>): grpc_1.ClientUnaryCall => {
            return super.GetTotalBalance(message, metadata, options, callback);
        };
        SignRawTransaction: GrpcUnaryServiceInterface<SignRawTransactionRequest, SignRawTransactionResponse> = (message: SignRawTransactionRequest, metadata: grpc_1.Metadata | grpc_1.CallOptions | grpc_1.requestCallback<SignRawTransactionResponse>, options?: grpc_1.CallOptions | grpc_1.requestCallback<SignRawTransactionResponse>, callback?: grpc_1.requestCallback<SignRawTransactionResponse>): grpc_1.ClientUnaryCall => {
            return super.SignRawTransaction(message, metadata, options, callback);
        };
        GetValidatorAddress: GrpcUnaryServiceInterface<GetValidatorAddressRequest, GetValidatorAddressResponse> = (message: GetValidatorAddressRequest, metadata: grpc_1.Metadata | grpc_1.CallOptions | grpc_1.requestCallback<GetValidatorAddressResponse>, options?: grpc_1.CallOptions | grpc_1.requestCallback<GetValidatorAddressResponse>, callback?: grpc_1.requestCallback<GetValidatorAddressResponse>): grpc_1.ClientUnaryCall => {
            return super.GetValidatorAddress(message, metadata, options, callback);
        };
        GetNewAddress: GrpcUnaryServiceInterface<GetNewAddressRequest, GetNewAddressResponse> = (message: GetNewAddressRequest, metadata: grpc_1.Metadata | grpc_1.CallOptions | grpc_1.requestCallback<GetNewAddressResponse>, options?: grpc_1.CallOptions | grpc_1.requestCallback<GetNewAddressResponse>, callback?: grpc_1.requestCallback<GetNewAddressResponse>): grpc_1.ClientUnaryCall => {
            return super.GetNewAddress(message, metadata, options, callback);
        };
        GetAddressHistory: GrpcUnaryServiceInterface<GetAddressHistoryRequest, GetAddressHistoryResponse> = (message: GetAddressHistoryRequest, metadata: grpc_1.Metadata | grpc_1.CallOptions | grpc_1.requestCallback<GetAddressHistoryResponse>, options?: grpc_1.CallOptions | grpc_1.requestCallback<GetAddressHistoryResponse>, callback?: grpc_1.requestCallback<GetAddressHistoryResponse>): grpc_1.ClientUnaryCall => {
            return super.GetAddressHistory(message, metadata, options, callback);
        };
        SignMessage: GrpcUnaryServiceInterface<SignMessageRequest, SignMessageResponse> = (message: SignMessageRequest, metadata: grpc_1.Metadata | grpc_1.CallOptions | grpc_1.requestCallback<SignMessageResponse>, options?: grpc_1.CallOptions | grpc_1.requestCallback<SignMessageResponse>, callback?: grpc_1.requestCallback<SignMessageResponse>): grpc_1.ClientUnaryCall => {
            return super.SignMessage(message, metadata, options, callback);
        };
    }
}
