/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 3.21.12
 * source: network.proto
 * git: https://github.com/thesayyn/protoc-gen-ts */
import * as pb_1 from "google-protobuf";
import * as grpc_1 from "@grpc/grpc-js";
export namespace pactus {
    export class GetNetworkInfoRequest extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            only_connected?: boolean;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("only_connected" in data && data.only_connected != undefined) {
                    this.only_connected = data.only_connected;
                }
            }
        }
        get only_connected() {
            return pb_1.Message.getFieldWithDefault(this, 1, false) as boolean;
        }
        set only_connected(value: boolean) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data: {
            only_connected?: boolean;
        }): GetNetworkInfoRequest {
            const message = new GetNetworkInfoRequest({});
            if (data.only_connected != null) {
                message.only_connected = data.only_connected;
            }
            return message;
        }
        toObject() {
            const data: {
                only_connected?: boolean;
            } = {};
            if (this.only_connected != null) {
                data.only_connected = this.only_connected;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.only_connected != false)
                writer.writeBool(1, this.only_connected);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): GetNetworkInfoRequest {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new GetNetworkInfoRequest();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.only_connected = reader.readBool();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): GetNetworkInfoRequest {
            return GetNetworkInfoRequest.deserialize(bytes);
        }
    }
    export class GetNetworkInfoResponse extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            network_name?: string;
            total_sent_bytes?: number;
            total_received_bytes?: number;
            connected_peers_count?: number;
            connected_peers?: PeerInfo[];
            sent_bytes?: Map<number, number>;
            received_bytes?: Map<number, number>;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [5], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("network_name" in data && data.network_name != undefined) {
                    this.network_name = data.network_name;
                }
                if ("total_sent_bytes" in data && data.total_sent_bytes != undefined) {
                    this.total_sent_bytes = data.total_sent_bytes;
                }
                if ("total_received_bytes" in data && data.total_received_bytes != undefined) {
                    this.total_received_bytes = data.total_received_bytes;
                }
                if ("connected_peers_count" in data && data.connected_peers_count != undefined) {
                    this.connected_peers_count = data.connected_peers_count;
                }
                if ("connected_peers" in data && data.connected_peers != undefined) {
                    this.connected_peers = data.connected_peers;
                }
                if ("sent_bytes" in data && data.sent_bytes != undefined) {
                    this.sent_bytes = data.sent_bytes;
                }
                if ("received_bytes" in data && data.received_bytes != undefined) {
                    this.received_bytes = data.received_bytes;
                }
            }
            if (!this.sent_bytes)
                this.sent_bytes = new Map();
            if (!this.received_bytes)
                this.received_bytes = new Map();
        }
        get network_name() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set network_name(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get total_sent_bytes() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set total_sent_bytes(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        get total_received_bytes() {
            return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
        }
        set total_received_bytes(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        get connected_peers_count() {
            return pb_1.Message.getFieldWithDefault(this, 4, 0) as number;
        }
        set connected_peers_count(value: number) {
            pb_1.Message.setField(this, 4, value);
        }
        get connected_peers() {
            return pb_1.Message.getRepeatedWrapperField(this, PeerInfo, 5) as PeerInfo[];
        }
        set connected_peers(value: PeerInfo[]) {
            pb_1.Message.setRepeatedWrapperField(this, 5, value);
        }
        get sent_bytes() {
            return pb_1.Message.getField(this, 6) as any as Map<number, number>;
        }
        set sent_bytes(value: Map<number, number>) {
            pb_1.Message.setField(this, 6, value as any);
        }
        get received_bytes() {
            return pb_1.Message.getField(this, 7) as any as Map<number, number>;
        }
        set received_bytes(value: Map<number, number>) {
            pb_1.Message.setField(this, 7, value as any);
        }
        static fromObject(data: {
            network_name?: string;
            total_sent_bytes?: number;
            total_received_bytes?: number;
            connected_peers_count?: number;
            connected_peers?: ReturnType<typeof PeerInfo.prototype.toObject>[];
            sent_bytes?: {
                [key: number]: number;
            };
            received_bytes?: {
                [key: number]: number;
            };
        }): GetNetworkInfoResponse {
            const message = new GetNetworkInfoResponse({});
            if (data.network_name != null) {
                message.network_name = data.network_name;
            }
            if (data.total_sent_bytes != null) {
                message.total_sent_bytes = data.total_sent_bytes;
            }
            if (data.total_received_bytes != null) {
                message.total_received_bytes = data.total_received_bytes;
            }
            if (data.connected_peers_count != null) {
                message.connected_peers_count = data.connected_peers_count;
            }
            if (data.connected_peers != null) {
                message.connected_peers = data.connected_peers.map(item => PeerInfo.fromObject(item));
            }
            if (typeof data.sent_bytes == "object") {
                message.sent_bytes = new Map(Object.entries(data.sent_bytes).map(([key, value]) => [Number(key), value]));
            }
            if (typeof data.received_bytes == "object") {
                message.received_bytes = new Map(Object.entries(data.received_bytes).map(([key, value]) => [Number(key), value]));
            }
            return message;
        }
        toObject() {
            const data: {
                network_name?: string;
                total_sent_bytes?: number;
                total_received_bytes?: number;
                connected_peers_count?: number;
                connected_peers?: ReturnType<typeof PeerInfo.prototype.toObject>[];
                sent_bytes?: {
                    [key: number]: number;
                };
                received_bytes?: {
                    [key: number]: number;
                };
            } = {};
            if (this.network_name != null) {
                data.network_name = this.network_name;
            }
            if (this.total_sent_bytes != null) {
                data.total_sent_bytes = this.total_sent_bytes;
            }
            if (this.total_received_bytes != null) {
                data.total_received_bytes = this.total_received_bytes;
            }
            if (this.connected_peers_count != null) {
                data.connected_peers_count = this.connected_peers_count;
            }
            if (this.connected_peers != null) {
                data.connected_peers = this.connected_peers.map((item: PeerInfo) => item.toObject());
            }
            if (this.sent_bytes != null) {
                data.sent_bytes = (Object.fromEntries)(this.sent_bytes);
            }
            if (this.received_bytes != null) {
                data.received_bytes = (Object.fromEntries)(this.received_bytes);
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.network_name.length)
                writer.writeString(1, this.network_name);
            if (this.total_sent_bytes != 0)
                writer.writeInt64(2, this.total_sent_bytes);
            if (this.total_received_bytes != 0)
                writer.writeInt64(3, this.total_received_bytes);
            if (this.connected_peers_count != 0)
                writer.writeUint32(4, this.connected_peers_count);
            if (this.connected_peers.length)
                writer.writeRepeatedMessage(5, this.connected_peers, (item: PeerInfo) => item.serialize(writer));
            for (const [key, value] of this.sent_bytes) {
                writer.writeMessage(6, this.sent_bytes, () => {
                    writer.writeInt32(1, key);
                    writer.writeInt64(2, value);
                });
            }
            for (const [key, value] of this.received_bytes) {
                writer.writeMessage(7, this.received_bytes, () => {
                    writer.writeInt32(1, key);
                    writer.writeInt64(2, value);
                });
            }
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): GetNetworkInfoResponse {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new GetNetworkInfoResponse();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.network_name = reader.readString();
                        break;
                    case 2:
                        message.total_sent_bytes = reader.readInt64();
                        break;
                    case 3:
                        message.total_received_bytes = reader.readInt64();
                        break;
                    case 4:
                        message.connected_peers_count = reader.readUint32();
                        break;
                    case 5:
                        reader.readMessage(message.connected_peers, () => pb_1.Message.addToRepeatedWrapperField(message, 5, PeerInfo.deserialize(reader), PeerInfo));
                        break;
                    case 6:
                        reader.readMessage(message, () => pb_1.Map.deserializeBinary(message.sent_bytes as any, reader, reader.readInt32, reader.readInt64));
                        break;
                    case 7:
                        reader.readMessage(message, () => pb_1.Map.deserializeBinary(message.received_bytes as any, reader, reader.readInt32, reader.readInt64));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): GetNetworkInfoResponse {
            return GetNetworkInfoResponse.deserialize(bytes);
        }
    }
    export class GetNodeInfoRequest extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {}) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") { }
        }
        static fromObject(data: {}): GetNodeInfoRequest {
            const message = new GetNodeInfoRequest({});
            return message;
        }
        toObject() {
            const data: {} = {};
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): GetNodeInfoRequest {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new GetNodeInfoRequest();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): GetNodeInfoRequest {
            return GetNodeInfoRequest.deserialize(bytes);
        }
    }
    export class GetNodeInfoResponse extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            moniker?: string;
            agent?: string;
            peer_id?: string;
            started_at?: number;
            reachability?: string;
            services?: number;
            services_names?: string;
            local_addrs?: string[];
            protocols?: string[];
            clock_offset?: number;
            connection_info?: ConnectionInfo;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [8, 9], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("moniker" in data && data.moniker != undefined) {
                    this.moniker = data.moniker;
                }
                if ("agent" in data && data.agent != undefined) {
                    this.agent = data.agent;
                }
                if ("peer_id" in data && data.peer_id != undefined) {
                    this.peer_id = data.peer_id;
                }
                if ("started_at" in data && data.started_at != undefined) {
                    this.started_at = data.started_at;
                }
                if ("reachability" in data && data.reachability != undefined) {
                    this.reachability = data.reachability;
                }
                if ("services" in data && data.services != undefined) {
                    this.services = data.services;
                }
                if ("services_names" in data && data.services_names != undefined) {
                    this.services_names = data.services_names;
                }
                if ("local_addrs" in data && data.local_addrs != undefined) {
                    this.local_addrs = data.local_addrs;
                }
                if ("protocols" in data && data.protocols != undefined) {
                    this.protocols = data.protocols;
                }
                if ("clock_offset" in data && data.clock_offset != undefined) {
                    this.clock_offset = data.clock_offset;
                }
                if ("connection_info" in data && data.connection_info != undefined) {
                    this.connection_info = data.connection_info;
                }
            }
        }
        get moniker() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set moniker(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get agent() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set agent(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get peer_id() {
            return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
        }
        set peer_id(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        get started_at() {
            return pb_1.Message.getFieldWithDefault(this, 4, 0) as number;
        }
        set started_at(value: number) {
            pb_1.Message.setField(this, 4, value);
        }
        get reachability() {
            return pb_1.Message.getFieldWithDefault(this, 5, "") as string;
        }
        set reachability(value: string) {
            pb_1.Message.setField(this, 5, value);
        }
        get services() {
            return pb_1.Message.getFieldWithDefault(this, 6, 0) as number;
        }
        set services(value: number) {
            pb_1.Message.setField(this, 6, value);
        }
        get services_names() {
            return pb_1.Message.getFieldWithDefault(this, 7, "") as string;
        }
        set services_names(value: string) {
            pb_1.Message.setField(this, 7, value);
        }
        get local_addrs() {
            return pb_1.Message.getFieldWithDefault(this, 8, []) as string[];
        }
        set local_addrs(value: string[]) {
            pb_1.Message.setField(this, 8, value);
        }
        get protocols() {
            return pb_1.Message.getFieldWithDefault(this, 9, []) as string[];
        }
        set protocols(value: string[]) {
            pb_1.Message.setField(this, 9, value);
        }
        get clock_offset() {
            return pb_1.Message.getFieldWithDefault(this, 13, 0) as number;
        }
        set clock_offset(value: number) {
            pb_1.Message.setField(this, 13, value);
        }
        get connection_info() {
            return pb_1.Message.getWrapperField(this, ConnectionInfo, 14) as ConnectionInfo;
        }
        set connection_info(value: ConnectionInfo) {
            pb_1.Message.setWrapperField(this, 14, value);
        }
        get has_connection_info() {
            return pb_1.Message.getField(this, 14) != null;
        }
        static fromObject(data: {
            moniker?: string;
            agent?: string;
            peer_id?: string;
            started_at?: number;
            reachability?: string;
            services?: number;
            services_names?: string;
            local_addrs?: string[];
            protocols?: string[];
            clock_offset?: number;
            connection_info?: ReturnType<typeof ConnectionInfo.prototype.toObject>;
        }): GetNodeInfoResponse {
            const message = new GetNodeInfoResponse({});
            if (data.moniker != null) {
                message.moniker = data.moniker;
            }
            if (data.agent != null) {
                message.agent = data.agent;
            }
            if (data.peer_id != null) {
                message.peer_id = data.peer_id;
            }
            if (data.started_at != null) {
                message.started_at = data.started_at;
            }
            if (data.reachability != null) {
                message.reachability = data.reachability;
            }
            if (data.services != null) {
                message.services = data.services;
            }
            if (data.services_names != null) {
                message.services_names = data.services_names;
            }
            if (data.local_addrs != null) {
                message.local_addrs = data.local_addrs;
            }
            if (data.protocols != null) {
                message.protocols = data.protocols;
            }
            if (data.clock_offset != null) {
                message.clock_offset = data.clock_offset;
            }
            if (data.connection_info != null) {
                message.connection_info = ConnectionInfo.fromObject(data.connection_info);
            }
            return message;
        }
        toObject() {
            const data: {
                moniker?: string;
                agent?: string;
                peer_id?: string;
                started_at?: number;
                reachability?: string;
                services?: number;
                services_names?: string;
                local_addrs?: string[];
                protocols?: string[];
                clock_offset?: number;
                connection_info?: ReturnType<typeof ConnectionInfo.prototype.toObject>;
            } = {};
            if (this.moniker != null) {
                data.moniker = this.moniker;
            }
            if (this.agent != null) {
                data.agent = this.agent;
            }
            if (this.peer_id != null) {
                data.peer_id = this.peer_id;
            }
            if (this.started_at != null) {
                data.started_at = this.started_at;
            }
            if (this.reachability != null) {
                data.reachability = this.reachability;
            }
            if (this.services != null) {
                data.services = this.services;
            }
            if (this.services_names != null) {
                data.services_names = this.services_names;
            }
            if (this.local_addrs != null) {
                data.local_addrs = this.local_addrs;
            }
            if (this.protocols != null) {
                data.protocols = this.protocols;
            }
            if (this.clock_offset != null) {
                data.clock_offset = this.clock_offset;
            }
            if (this.connection_info != null) {
                data.connection_info = this.connection_info.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.moniker.length)
                writer.writeString(1, this.moniker);
            if (this.agent.length)
                writer.writeString(2, this.agent);
            if (this.peer_id.length)
                writer.writeString(3, this.peer_id);
            if (this.started_at != 0)
                writer.writeUint64(4, this.started_at);
            if (this.reachability.length)
                writer.writeString(5, this.reachability);
            if (this.services != 0)
                writer.writeInt32(6, this.services);
            if (this.services_names.length)
                writer.writeString(7, this.services_names);
            if (this.local_addrs.length)
                writer.writeRepeatedString(8, this.local_addrs);
            if (this.protocols.length)
                writer.writeRepeatedString(9, this.protocols);
            if (this.clock_offset != 0)
                writer.writeDouble(13, this.clock_offset);
            if (this.has_connection_info)
                writer.writeMessage(14, this.connection_info, () => this.connection_info.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): GetNodeInfoResponse {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new GetNodeInfoResponse();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.moniker = reader.readString();
                        break;
                    case 2:
                        message.agent = reader.readString();
                        break;
                    case 3:
                        message.peer_id = reader.readString();
                        break;
                    case 4:
                        message.started_at = reader.readUint64();
                        break;
                    case 5:
                        message.reachability = reader.readString();
                        break;
                    case 6:
                        message.services = reader.readInt32();
                        break;
                    case 7:
                        message.services_names = reader.readString();
                        break;
                    case 8:
                        pb_1.Message.addToRepeatedField(message, 8, reader.readString());
                        break;
                    case 9:
                        pb_1.Message.addToRepeatedField(message, 9, reader.readString());
                        break;
                    case 13:
                        message.clock_offset = reader.readDouble();
                        break;
                    case 14:
                        reader.readMessage(message.connection_info, () => message.connection_info = ConnectionInfo.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): GetNodeInfoResponse {
            return GetNodeInfoResponse.deserialize(bytes);
        }
    }
    export class PeerInfo extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            status?: number;
            moniker?: string;
            agent?: string;
            peer_id?: string;
            consensus_keys?: string[];
            consensus_addresses?: string[];
            services?: number;
            last_block_hash?: string;
            height?: number;
            received_bundles?: number;
            invalid_bundles?: number;
            last_sent?: number;
            last_received?: number;
            sent_bytes?: Map<number, number>;
            received_bytes?: Map<number, number>;
            address?: string;
            direction?: string;
            protocols?: string[];
            total_sessions?: number;
            completed_sessions?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [5, 6, 18], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("status" in data && data.status != undefined) {
                    this.status = data.status;
                }
                if ("moniker" in data && data.moniker != undefined) {
                    this.moniker = data.moniker;
                }
                if ("agent" in data && data.agent != undefined) {
                    this.agent = data.agent;
                }
                if ("peer_id" in data && data.peer_id != undefined) {
                    this.peer_id = data.peer_id;
                }
                if ("consensus_keys" in data && data.consensus_keys != undefined) {
                    this.consensus_keys = data.consensus_keys;
                }
                if ("consensus_addresses" in data && data.consensus_addresses != undefined) {
                    this.consensus_addresses = data.consensus_addresses;
                }
                if ("services" in data && data.services != undefined) {
                    this.services = data.services;
                }
                if ("last_block_hash" in data && data.last_block_hash != undefined) {
                    this.last_block_hash = data.last_block_hash;
                }
                if ("height" in data && data.height != undefined) {
                    this.height = data.height;
                }
                if ("received_bundles" in data && data.received_bundles != undefined) {
                    this.received_bundles = data.received_bundles;
                }
                if ("invalid_bundles" in data && data.invalid_bundles != undefined) {
                    this.invalid_bundles = data.invalid_bundles;
                }
                if ("last_sent" in data && data.last_sent != undefined) {
                    this.last_sent = data.last_sent;
                }
                if ("last_received" in data && data.last_received != undefined) {
                    this.last_received = data.last_received;
                }
                if ("sent_bytes" in data && data.sent_bytes != undefined) {
                    this.sent_bytes = data.sent_bytes;
                }
                if ("received_bytes" in data && data.received_bytes != undefined) {
                    this.received_bytes = data.received_bytes;
                }
                if ("address" in data && data.address != undefined) {
                    this.address = data.address;
                }
                if ("direction" in data && data.direction != undefined) {
                    this.direction = data.direction;
                }
                if ("protocols" in data && data.protocols != undefined) {
                    this.protocols = data.protocols;
                }
                if ("total_sessions" in data && data.total_sessions != undefined) {
                    this.total_sessions = data.total_sessions;
                }
                if ("completed_sessions" in data && data.completed_sessions != undefined) {
                    this.completed_sessions = data.completed_sessions;
                }
            }
            if (!this.sent_bytes)
                this.sent_bytes = new Map();
            if (!this.received_bytes)
                this.received_bytes = new Map();
        }
        get status() {
            return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
        }
        set status(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        get moniker() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set moniker(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get agent() {
            return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
        }
        set agent(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        get peer_id() {
            return pb_1.Message.getFieldWithDefault(this, 4, "") as string;
        }
        set peer_id(value: string) {
            pb_1.Message.setField(this, 4, value);
        }
        get consensus_keys() {
            return pb_1.Message.getFieldWithDefault(this, 5, []) as string[];
        }
        set consensus_keys(value: string[]) {
            pb_1.Message.setField(this, 5, value);
        }
        get consensus_addresses() {
            return pb_1.Message.getFieldWithDefault(this, 6, []) as string[];
        }
        set consensus_addresses(value: string[]) {
            pb_1.Message.setField(this, 6, value);
        }
        get services() {
            return pb_1.Message.getFieldWithDefault(this, 7, 0) as number;
        }
        set services(value: number) {
            pb_1.Message.setField(this, 7, value);
        }
        get last_block_hash() {
            return pb_1.Message.getFieldWithDefault(this, 8, "") as string;
        }
        set last_block_hash(value: string) {
            pb_1.Message.setField(this, 8, value);
        }
        get height() {
            return pb_1.Message.getFieldWithDefault(this, 9, 0) as number;
        }
        set height(value: number) {
            pb_1.Message.setField(this, 9, value);
        }
        get received_bundles() {
            return pb_1.Message.getFieldWithDefault(this, 10, 0) as number;
        }
        set received_bundles(value: number) {
            pb_1.Message.setField(this, 10, value);
        }
        get invalid_bundles() {
            return pb_1.Message.getFieldWithDefault(this, 11, 0) as number;
        }
        set invalid_bundles(value: number) {
            pb_1.Message.setField(this, 11, value);
        }
        get last_sent() {
            return pb_1.Message.getFieldWithDefault(this, 12, 0) as number;
        }
        set last_sent(value: number) {
            pb_1.Message.setField(this, 12, value);
        }
        get last_received() {
            return pb_1.Message.getFieldWithDefault(this, 13, 0) as number;
        }
        set last_received(value: number) {
            pb_1.Message.setField(this, 13, value);
        }
        get sent_bytes() {
            return pb_1.Message.getField(this, 14) as any as Map<number, number>;
        }
        set sent_bytes(value: Map<number, number>) {
            pb_1.Message.setField(this, 14, value as any);
        }
        get received_bytes() {
            return pb_1.Message.getField(this, 15) as any as Map<number, number>;
        }
        set received_bytes(value: Map<number, number>) {
            pb_1.Message.setField(this, 15, value as any);
        }
        get address() {
            return pb_1.Message.getFieldWithDefault(this, 16, "") as string;
        }
        set address(value: string) {
            pb_1.Message.setField(this, 16, value);
        }
        get direction() {
            return pb_1.Message.getFieldWithDefault(this, 17, "") as string;
        }
        set direction(value: string) {
            pb_1.Message.setField(this, 17, value);
        }
        get protocols() {
            return pb_1.Message.getFieldWithDefault(this, 18, []) as string[];
        }
        set protocols(value: string[]) {
            pb_1.Message.setField(this, 18, value);
        }
        get total_sessions() {
            return pb_1.Message.getFieldWithDefault(this, 19, 0) as number;
        }
        set total_sessions(value: number) {
            pb_1.Message.setField(this, 19, value);
        }
        get completed_sessions() {
            return pb_1.Message.getFieldWithDefault(this, 20, 0) as number;
        }
        set completed_sessions(value: number) {
            pb_1.Message.setField(this, 20, value);
        }
        static fromObject(data: {
            status?: number;
            moniker?: string;
            agent?: string;
            peer_id?: string;
            consensus_keys?: string[];
            consensus_addresses?: string[];
            services?: number;
            last_block_hash?: string;
            height?: number;
            received_bundles?: number;
            invalid_bundles?: number;
            last_sent?: number;
            last_received?: number;
            sent_bytes?: {
                [key: number]: number;
            };
            received_bytes?: {
                [key: number]: number;
            };
            address?: string;
            direction?: string;
            protocols?: string[];
            total_sessions?: number;
            completed_sessions?: number;
        }): PeerInfo {
            const message = new PeerInfo({});
            if (data.status != null) {
                message.status = data.status;
            }
            if (data.moniker != null) {
                message.moniker = data.moniker;
            }
            if (data.agent != null) {
                message.agent = data.agent;
            }
            if (data.peer_id != null) {
                message.peer_id = data.peer_id;
            }
            if (data.consensus_keys != null) {
                message.consensus_keys = data.consensus_keys;
            }
            if (data.consensus_addresses != null) {
                message.consensus_addresses = data.consensus_addresses;
            }
            if (data.services != null) {
                message.services = data.services;
            }
            if (data.last_block_hash != null) {
                message.last_block_hash = data.last_block_hash;
            }
            if (data.height != null) {
                message.height = data.height;
            }
            if (data.received_bundles != null) {
                message.received_bundles = data.received_bundles;
            }
            if (data.invalid_bundles != null) {
                message.invalid_bundles = data.invalid_bundles;
            }
            if (data.last_sent != null) {
                message.last_sent = data.last_sent;
            }
            if (data.last_received != null) {
                message.last_received = data.last_received;
            }
            if (typeof data.sent_bytes == "object") {
                message.sent_bytes = new Map(Object.entries(data.sent_bytes).map(([key, value]) => [Number(key), value]));
            }
            if (typeof data.received_bytes == "object") {
                message.received_bytes = new Map(Object.entries(data.received_bytes).map(([key, value]) => [Number(key), value]));
            }
            if (data.address != null) {
                message.address = data.address;
            }
            if (data.direction != null) {
                message.direction = data.direction;
            }
            if (data.protocols != null) {
                message.protocols = data.protocols;
            }
            if (data.total_sessions != null) {
                message.total_sessions = data.total_sessions;
            }
            if (data.completed_sessions != null) {
                message.completed_sessions = data.completed_sessions;
            }
            return message;
        }
        toObject() {
            const data: {
                status?: number;
                moniker?: string;
                agent?: string;
                peer_id?: string;
                consensus_keys?: string[];
                consensus_addresses?: string[];
                services?: number;
                last_block_hash?: string;
                height?: number;
                received_bundles?: number;
                invalid_bundles?: number;
                last_sent?: number;
                last_received?: number;
                sent_bytes?: {
                    [key: number]: number;
                };
                received_bytes?: {
                    [key: number]: number;
                };
                address?: string;
                direction?: string;
                protocols?: string[];
                total_sessions?: number;
                completed_sessions?: number;
            } = {};
            if (this.status != null) {
                data.status = this.status;
            }
            if (this.moniker != null) {
                data.moniker = this.moniker;
            }
            if (this.agent != null) {
                data.agent = this.agent;
            }
            if (this.peer_id != null) {
                data.peer_id = this.peer_id;
            }
            if (this.consensus_keys != null) {
                data.consensus_keys = this.consensus_keys;
            }
            if (this.consensus_addresses != null) {
                data.consensus_addresses = this.consensus_addresses;
            }
            if (this.services != null) {
                data.services = this.services;
            }
            if (this.last_block_hash != null) {
                data.last_block_hash = this.last_block_hash;
            }
            if (this.height != null) {
                data.height = this.height;
            }
            if (this.received_bundles != null) {
                data.received_bundles = this.received_bundles;
            }
            if (this.invalid_bundles != null) {
                data.invalid_bundles = this.invalid_bundles;
            }
            if (this.last_sent != null) {
                data.last_sent = this.last_sent;
            }
            if (this.last_received != null) {
                data.last_received = this.last_received;
            }
            if (this.sent_bytes != null) {
                data.sent_bytes = (Object.fromEntries)(this.sent_bytes);
            }
            if (this.received_bytes != null) {
                data.received_bytes = (Object.fromEntries)(this.received_bytes);
            }
            if (this.address != null) {
                data.address = this.address;
            }
            if (this.direction != null) {
                data.direction = this.direction;
            }
            if (this.protocols != null) {
                data.protocols = this.protocols;
            }
            if (this.total_sessions != null) {
                data.total_sessions = this.total_sessions;
            }
            if (this.completed_sessions != null) {
                data.completed_sessions = this.completed_sessions;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.status != 0)
                writer.writeInt32(1, this.status);
            if (this.moniker.length)
                writer.writeString(2, this.moniker);
            if (this.agent.length)
                writer.writeString(3, this.agent);
            if (this.peer_id.length)
                writer.writeString(4, this.peer_id);
            if (this.consensus_keys.length)
                writer.writeRepeatedString(5, this.consensus_keys);
            if (this.consensus_addresses.length)
                writer.writeRepeatedString(6, this.consensus_addresses);
            if (this.services != 0)
                writer.writeUint32(7, this.services);
            if (this.last_block_hash.length)
                writer.writeString(8, this.last_block_hash);
            if (this.height != 0)
                writer.writeUint32(9, this.height);
            if (this.received_bundles != 0)
                writer.writeInt32(10, this.received_bundles);
            if (this.invalid_bundles != 0)
                writer.writeInt32(11, this.invalid_bundles);
            if (this.last_sent != 0)
                writer.writeInt64(12, this.last_sent);
            if (this.last_received != 0)
                writer.writeInt64(13, this.last_received);
            for (const [key, value] of this.sent_bytes) {
                writer.writeMessage(14, this.sent_bytes, () => {
                    writer.writeInt32(1, key);
                    writer.writeInt64(2, value);
                });
            }
            for (const [key, value] of this.received_bytes) {
                writer.writeMessage(15, this.received_bytes, () => {
                    writer.writeInt32(1, key);
                    writer.writeInt64(2, value);
                });
            }
            if (this.address.length)
                writer.writeString(16, this.address);
            if (this.direction.length)
                writer.writeString(17, this.direction);
            if (this.protocols.length)
                writer.writeRepeatedString(18, this.protocols);
            if (this.total_sessions != 0)
                writer.writeInt32(19, this.total_sessions);
            if (this.completed_sessions != 0)
                writer.writeInt32(20, this.completed_sessions);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): PeerInfo {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new PeerInfo();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.status = reader.readInt32();
                        break;
                    case 2:
                        message.moniker = reader.readString();
                        break;
                    case 3:
                        message.agent = reader.readString();
                        break;
                    case 4:
                        message.peer_id = reader.readString();
                        break;
                    case 5:
                        pb_1.Message.addToRepeatedField(message, 5, reader.readString());
                        break;
                    case 6:
                        pb_1.Message.addToRepeatedField(message, 6, reader.readString());
                        break;
                    case 7:
                        message.services = reader.readUint32();
                        break;
                    case 8:
                        message.last_block_hash = reader.readString();
                        break;
                    case 9:
                        message.height = reader.readUint32();
                        break;
                    case 10:
                        message.received_bundles = reader.readInt32();
                        break;
                    case 11:
                        message.invalid_bundles = reader.readInt32();
                        break;
                    case 12:
                        message.last_sent = reader.readInt64();
                        break;
                    case 13:
                        message.last_received = reader.readInt64();
                        break;
                    case 14:
                        reader.readMessage(message, () => pb_1.Map.deserializeBinary(message.sent_bytes as any, reader, reader.readInt32, reader.readInt64));
                        break;
                    case 15:
                        reader.readMessage(message, () => pb_1.Map.deserializeBinary(message.received_bytes as any, reader, reader.readInt32, reader.readInt64));
                        break;
                    case 16:
                        message.address = reader.readString();
                        break;
                    case 17:
                        message.direction = reader.readString();
                        break;
                    case 18:
                        pb_1.Message.addToRepeatedField(message, 18, reader.readString());
                        break;
                    case 19:
                        message.total_sessions = reader.readInt32();
                        break;
                    case 20:
                        message.completed_sessions = reader.readInt32();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): PeerInfo {
            return PeerInfo.deserialize(bytes);
        }
    }
    export class ConnectionInfo extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            connections?: number;
            inbound_connections?: number;
            outbound_connections?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("connections" in data && data.connections != undefined) {
                    this.connections = data.connections;
                }
                if ("inbound_connections" in data && data.inbound_connections != undefined) {
                    this.inbound_connections = data.inbound_connections;
                }
                if ("outbound_connections" in data && data.outbound_connections != undefined) {
                    this.outbound_connections = data.outbound_connections;
                }
            }
        }
        get connections() {
            return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
        }
        set connections(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        get inbound_connections() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set inbound_connections(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        get outbound_connections() {
            return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
        }
        set outbound_connections(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        static fromObject(data: {
            connections?: number;
            inbound_connections?: number;
            outbound_connections?: number;
        }): ConnectionInfo {
            const message = new ConnectionInfo({});
            if (data.connections != null) {
                message.connections = data.connections;
            }
            if (data.inbound_connections != null) {
                message.inbound_connections = data.inbound_connections;
            }
            if (data.outbound_connections != null) {
                message.outbound_connections = data.outbound_connections;
            }
            return message;
        }
        toObject() {
            const data: {
                connections?: number;
                inbound_connections?: number;
                outbound_connections?: number;
            } = {};
            if (this.connections != null) {
                data.connections = this.connections;
            }
            if (this.inbound_connections != null) {
                data.inbound_connections = this.inbound_connections;
            }
            if (this.outbound_connections != null) {
                data.outbound_connections = this.outbound_connections;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.connections != 0)
                writer.writeUint64(1, this.connections);
            if (this.inbound_connections != 0)
                writer.writeUint64(2, this.inbound_connections);
            if (this.outbound_connections != 0)
                writer.writeUint64(3, this.outbound_connections);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ConnectionInfo {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ConnectionInfo();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.connections = reader.readUint64();
                        break;
                    case 2:
                        message.inbound_connections = reader.readUint64();
                        break;
                    case 3:
                        message.outbound_connections = reader.readUint64();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): ConnectionInfo {
            return ConnectionInfo.deserialize(bytes);
        }
    }
    interface GrpcUnaryServiceInterface<P, R> {
        (message: P, metadata: grpc_1.Metadata, options: grpc_1.CallOptions, callback: grpc_1.requestCallback<R>): grpc_1.ClientUnaryCall;
        (message: P, metadata: grpc_1.Metadata, callback: grpc_1.requestCallback<R>): grpc_1.ClientUnaryCall;
        (message: P, options: grpc_1.CallOptions, callback: grpc_1.requestCallback<R>): grpc_1.ClientUnaryCall;
        (message: P, callback: grpc_1.requestCallback<R>): grpc_1.ClientUnaryCall;
    }
    interface GrpcStreamServiceInterface<P, R> {
        (message: P, metadata: grpc_1.Metadata, options?: grpc_1.CallOptions): grpc_1.ClientReadableStream<R>;
        (message: P, options?: grpc_1.CallOptions): grpc_1.ClientReadableStream<R>;
    }
    interface GrpWritableServiceInterface<P, R> {
        (metadata: grpc_1.Metadata, options: grpc_1.CallOptions, callback: grpc_1.requestCallback<R>): grpc_1.ClientWritableStream<P>;
        (metadata: grpc_1.Metadata, callback: grpc_1.requestCallback<R>): grpc_1.ClientWritableStream<P>;
        (options: grpc_1.CallOptions, callback: grpc_1.requestCallback<R>): grpc_1.ClientWritableStream<P>;
        (callback: grpc_1.requestCallback<R>): grpc_1.ClientWritableStream<P>;
    }
    interface GrpcChunkServiceInterface<P, R> {
        (metadata: grpc_1.Metadata, options?: grpc_1.CallOptions): grpc_1.ClientDuplexStream<P, R>;
        (options?: grpc_1.CallOptions): grpc_1.ClientDuplexStream<P, R>;
    }
    interface GrpcPromiseServiceInterface<P, R> {
        (message: P, metadata: grpc_1.Metadata, options?: grpc_1.CallOptions): Promise<R>;
        (message: P, options?: grpc_1.CallOptions): Promise<R>;
    }
    export abstract class UnimplementedNetworkService {
        static definition = {
            GetNetworkInfo: {
                path: "/pactus.Network/GetNetworkInfo",
                requestStream: false,
                responseStream: false,
                requestSerialize: (message: GetNetworkInfoRequest) => Buffer.from(message.serialize()),
                requestDeserialize: (bytes: Buffer) => GetNetworkInfoRequest.deserialize(new Uint8Array(bytes)),
                responseSerialize: (message: GetNetworkInfoResponse) => Buffer.from(message.serialize()),
                responseDeserialize: (bytes: Buffer) => GetNetworkInfoResponse.deserialize(new Uint8Array(bytes))
            },
            GetNodeInfo: {
                path: "/pactus.Network/GetNodeInfo",
                requestStream: false,
                responseStream: false,
                requestSerialize: (message: GetNodeInfoRequest) => Buffer.from(message.serialize()),
                requestDeserialize: (bytes: Buffer) => GetNodeInfoRequest.deserialize(new Uint8Array(bytes)),
                responseSerialize: (message: GetNodeInfoResponse) => Buffer.from(message.serialize()),
                responseDeserialize: (bytes: Buffer) => GetNodeInfoResponse.deserialize(new Uint8Array(bytes))
            }
        };
        [method: string]: grpc_1.UntypedHandleCall;
        abstract GetNetworkInfo(call: grpc_1.ServerUnaryCall<GetNetworkInfoRequest, GetNetworkInfoResponse>, callback: grpc_1.sendUnaryData<GetNetworkInfoResponse>): void;
        abstract GetNodeInfo(call: grpc_1.ServerUnaryCall<GetNodeInfoRequest, GetNodeInfoResponse>, callback: grpc_1.sendUnaryData<GetNodeInfoResponse>): void;
    }
    export class NetworkClient extends grpc_1.makeGenericClientConstructor(UnimplementedNetworkService.definition, "Network", {}) {
        constructor(address: string, credentials: grpc_1.ChannelCredentials, options?: Partial<grpc_1.ChannelOptions>) {
            super(address, credentials, options);
        }
        GetNetworkInfo: GrpcUnaryServiceInterface<GetNetworkInfoRequest, GetNetworkInfoResponse> = (message: GetNetworkInfoRequest, metadata: grpc_1.Metadata | grpc_1.CallOptions | grpc_1.requestCallback<GetNetworkInfoResponse>, options?: grpc_1.CallOptions | grpc_1.requestCallback<GetNetworkInfoResponse>, callback?: grpc_1.requestCallback<GetNetworkInfoResponse>): grpc_1.ClientUnaryCall => {
            return super.GetNetworkInfo(message, metadata, options, callback);
        };
        GetNodeInfo: GrpcUnaryServiceInterface<GetNodeInfoRequest, GetNodeInfoResponse> = (message: GetNodeInfoRequest, metadata: grpc_1.Metadata | grpc_1.CallOptions | grpc_1.requestCallback<GetNodeInfoResponse>, options?: grpc_1.CallOptions | grpc_1.requestCallback<GetNodeInfoResponse>, callback?: grpc_1.requestCallback<GetNodeInfoResponse>): grpc_1.ClientUnaryCall => {
            return super.GetNodeInfo(message, metadata, options, callback);
        };
    }
}
